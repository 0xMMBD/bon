# Overview

`bon` is a Rust crate for generating type-safe builders for functions and structs.

## Builder for a function

`bon` can turn a function with many positional parameters into a function with "named" parameters via a builder. It's as easy as placing `#[builder]` macro on top of your function.

**Example:**

```rust
use bon::builder;

#[builder] // [!code highlight]
fn greet(name: &str, age: u32) -> String {
    format!("Hello {name} with age {age}!")
}

let greeting = greet()
    .name("Bon")
    .age(24)
    .call();

assert_eq!(greeting, "Hello Bon with age 24!");
```

::: tip

Many things are customizable with additional attributes. See the [`#[builder]` macro reference](../reference/builder) for details.

:::

## Builder for an associated method

You can also generate a builder for associated methods.

**Example:**

```rust
use bon::bon;

struct Counter {
    val: u32,
}

#[bon] // <- this macro is required on the impl block // [!code highlight]
impl Counter {
    #[builder] // [!code highlight]
    fn new(initial: Option<u32>) -> Self {
        Self {
            val: initial.unwrap_or_default(),
        }
    }

    #[builder] // [!code highlight]
    fn increment(&mut self, diff: u32) {
        self.val += diff;
    }
}

let mut counter = Counter::builder()
    .initial(3)
    .build();

counter
    .increment()
    .diff(3)
    .call();

assert_eq!(counter.val, 6);
```

::: details Why is that `#[bon]` macro on top of the `impl` block required? ðŸ¤”

There are a couple of technical reasons.

First of all, it's the lack of surrounding context given to a proc macro in Rust. A proc macro sees only the syntax it is placed on top of. For example, the `#[builder]` macro inside of the `impl` block can't see the `impl Counter` part of the impl block above it. However, it needs that information to tell the actual type of `Self`.

Second, `#[builder]` proc macro generates new items such as the builder struct type definition, which it needs to output **adjecently** to the `impl` block itself. However, proc macros in Rust can only modify the part of the syntax they are placed on and generate new items on the same level of nesting. The `#[builder]` macro inside of the impl block can't just break out of it.

:::


To follow usual Rust's builder naming conventions `bon` treats the `new` method specially.

Method name        | Start function name | Finish function name
-------------------| ------------------- | --------------------
`new`              | `builder`           | `build`
`{any_other_name}` | `{any_other_name}`  | `call`

## Builder for a struct

`bon` supports the classic pattern of annotating a struct to generate a builder.

**Example:**

```rust
use bon::builder;

#[builder]
struct User {
    id: u32,
    name: String,
}

let user = User::builder()
    .id(1)
    .name("Bon")
    .build();

assert_eq!(user.id, 1);
assert_eq!(user.name, "Bon");
```

::: tip

`#[builder]` on a struct generates builder API that is fully compatible with placing `#[builder]` on the `new()` method with the signature similar to struct's fields. See [compatibility](./compatibility#moving-builder-from-the-struct-the-new-method) page for details.

:::

## Type safe. No panics

The builders generated by `#[builder]` are all type-safe. They use the typestate pattern to make sure all required values are filled and setter methods aren't called repeatedly to prevent unintentional overwrites and typos. If something is wrong, a compile error will be created. There are no potential panics and `unwrap()` calls inside of the builder.


## Supported syntax for functions

`#[builder]` attribute works almost with any kind of function that uses any available Rust syntax.
All of the following is supported.

- Functions can return any values including `Result`, `Option`, etc.
- `impl Trait` syntax is supported both in function parameters and return type.
- `async` functions.
- `unsafe` functions.
- Generic type parameters.
- Generic const parameters (const generics).
- Generic lifetimes.
- `where` clauses.
- Anonymous lifetimes, i.e. `'_` or just regular references without explicit lifetimes like `&u32`.
- Nested functions defined inside of other items bodies. E.g.
  ```rust
  fn foo() {
      // Just works
      #[bon::builder]
      fn bar() {}
  }
  ```

## What's next?

You may consider reading the rest of the `Guide` section to harness the full power of `bon` and understand the decisions it makes. However, feel free to skip the docs and just use the `#[builder]` macro in your code. It's designed to be intuitive, so it'll probably do the thing you want it to do already.

If you find something unexpected or you don't know something, then consult the docs and maybe use that search :mag: `Search` thing at the top to navigate.

## Acknowledgments

The design of the generated builders was heavily inspired by such awesome crates as [`buildstructor`](https://docs.rs/buildstructor), [`typed-builder`](https://docs.rs/typed-builder) and [`derive-builder`](https://docs.rs/derive-builder). This crate was designed as an evolution of both of these with many lessons learned and a bunch more batteries provided.
