# Overview

`bon` is a Rust crate for generating type-safe builders for functions and structs.

## Builder for a function

`bon` can turn a function with many positional parameters into a function with "named" parameters via a builder. It's as easy as placing `#[builder]` macro on top of your function.

**Example:**

```rust
use bon::builder;

#[builder] // [!code highlight]
fn greet(name: &str, age: u32) -> String {
    format!("Hello {name} with age {age}!")
}

let greeting = greet()
    .name("Bon")
    .age(24)
    .call();

assert_eq!(greeting, "Hello Bon with age 24!");
```

::: tip

Many things are customizable with additional attributes. See the [`#[builder]` macro reference](../reference/builder) for details.

:::

## Builder for an associated method

You can also generate a builder for associated methods.

**Example:**

```rust
use bon::bon;

struct Counter {
    val: u32,
}

#[bon] // <- this macro is required on the impl block // [!code highlight]
impl Counter {
    #[builder] // [!code highlight]
    fn new(initial: Option<u32>) -> Self {
        Self {
            val: initial.unwrap_or_default(),
        }
    }

    #[builder] // [!code highlight]
    fn increment(&mut self, diff: u32) {
        self.val += diff;
    }
}

let mut counter = Counter::builder()
    .initial(3)
    .build();

counter
    .increment()
    .diff(3)
    .call();

assert_eq!(counter.val, 6);
```

::: details Why is that `#[bon]` macro on top of the `impl` block required? ðŸ¤”

There are a couple of technical reasons.

First of all, it's the lack of surrounding context given to a proc macro in Rust. A proc macro sees only the syntax it is placed on top of. For example, the `#[builder]` macro inside of the `impl` block can't see the `impl Counter` part of the impl block above it. However, it needs that information to tell the actual type of `Self`.

Second, `#[builder]` proc macro generates new items such as the builder struct type definition, which it needs to output **adjecently** to the `impl` block itself. However, proc macros in Rust can only modify the part of the syntax they are placed on and generate new items on the same level of nesting. The `#[builder]` macro inside of the impl block can't just break out of it.

:::


To follow usual Rust's builder naming conventions `bon` treats the `new` method specially.

Method name        | Start function name | Finish function name
-------------------| ------------------- | --------------------
`new`              | `builder`           | `build`
`{any_other_name}` | `{any_other_name}`  | `call`

## Builder for a struct

`bon` supports the classic pattern of annotating a struct to generate a builder.

**Example:**

```rust
use bon::builder;

#[builder]
struct User {
    id: u32,
    name: String,
}

let user = User::builder()
    .id(1)
    .name("Bon")
    .build();

assert_eq!(user.id, 1);
assert_eq!(user.name, "Bon");
```

### Compatibility with `#[builder]` on `new()` method

This syntax is fully compatible with defining a `new()` method annotated with the `#[builder]` attribute. The APIs generated in both cases are equivalent.

This means, for example, it's preferable to place the `#[builder]` attribute on top of your struct in most cases because it's convenient. However, if you need to have some custom logic during the construction of your type, you may simply create a `new()` method annotated with `#[builder]` where you can do anything you want to create an instance of your type.

To keep type's public API compatible with the time when `#[builder]` was on the struct directly, the `new()` method must accept the same parameters as there were fields on the struct.

**Example:**

```rust
use bon::bon;

struct User {
    // Suppose we decided to change the internal representation // [!code highlight]
    // of the `id` field of the struct to use `String`          // [!code highlight]
    id: String,                                                 // [!code highlight]
    name: String,
}

#[bon] // [!code highlight]
impl User {
    #[builder] // [!code highlight]
    fn new(id: u32, name: String) -> Self {
        Self {
            id: format!("u-{id}"),
            name: String,
        }
    }
}

// This code still compiles since the API of the builder didn't change // [!code highlight]
let user = User::builder()
    // `id` is still accepted as a `u32` here
    .id(1)
    .name("Bon")
    .build();

assert_eq!(user.id, "u-1");
assert_eq!(user.name, "Bon");
```

## Type safe. No panics

The builders generated by `#[builder]` are all type-safe. They use the typestate pattern to make sure all required values are filled and setter methods aren't called repeatedly to prevent unintentional overwrites and typos. If something is wrong, a compile error will be created. There are no potential panics and `unwrap()` calls inside of the builder.


## Supported syntax for functions

`#[builder]` attribute works almost with any kind of function that uses any available Rust syntax.
All of the following is supported.

- Functions can return any values including `Result`, `Option`, etc.
- `impl Trait` syntax is supported both in function parameters and return type.
- `async` functions.
- `unsafe` functions.
- Generic type parameters.
- Generic const parameters (const generics).
- Generic lifetimes.
- `where` clauses.
- Anonymous lifetimes, i.e. `'_` or just regular references without explicit lifetimes like `&u32`.
- Nested functions defined inside of other items bodies. E.g.
  ```rust
  fn foo() {
      // Just works
      #[bon::builder]
      fn bar() {}
  }
  ```

## Documentation for setters

In regular Rust, it's not possible to place doc comments on function arguments. But with `#[builder]` it is. Documentation written on the arguments will be placed on the generated setter methods.

**Example:**

```rust
use bon::builder;

/// Function that returns a greeting special-tailored for a given person
#[builder]
fn greet(
    /// Name of the person to greet.
    ///
    /// **Example:**
    /// ```
    /// greet().name("John");
    /// ```
    name: &str,

    /// Age expressed in full years passed since the birth date.
    age: u32
) -> String {
    format!("Hello {name} with age {age}!")
}
```

::: details How does this work? ðŸ¤”

This works because Rust compiler checks for invalid placement of `#[doc = ...]` attributes only after the macro expansion stage. `#[builder]` makes sure to remove the docs from the function's arguments in the expanded code, and instead moves them to the docs on setter methods.

:::

When `#[builder]` is placed on top of a struct, then documentation from the struct fields will be copied to the docs on the setter methods.

## Adding `#[builder]` to existing code

If your existing code defines functions with positional parameters in its public API that you'd like to change to use builder syntax, but you want to keep the old code compatible with the positional functions API, then you may use `#[builder(expose_positional_fn)]` attribute to keep both syntaxes available. See [this attribute's docs](../reference/builder#expose-positional-fn) for details.

## What's next?

If you made it to here you might consider reading the rest of the `Guide` section to harness the full power of `bon` and understand the decisions it makes. However, feel free to skip the docs and just use the `#[builder]` macro in your code. It's designed to be intuitive, so it'll probably do the thing you want it to do already.

If you find something unexpected, then consult the docs and maybe use that search :mag: `Search` thing at the top to navigate.

## References

The design of the generated builders was heavily inspired by such awesome crates as [`buildstructor`](https://docs.rs/buildstructor) and [`typed-builder`](https://docs.rs/typed-builder). This crate was designed as an evolution of both of these with many lessons learned and a bunch more batteries provided.
